Description: CVE-2015-5602: sudoedit path restriction bypass using symlinks
 Do not follow symbolic links in sudoedit by default.  This behavior
 can be controlled by the sudoedit_follow Defaults flag as well as
 the FOLLOW/NOFOLLOW tags.
Origin: backport, https://www.sudo.ws/repos/sudo/rev/9636fd256325
Bug: https://bugzilla.sudo.ws/show_bug.cgi?id=707
Bug-Debian: https://bugs.debian.org/804149
Author: Todd C. Miller <Todd.Miller@courtesan.com>
Author: Ben Hutchings <ben@decadent.org.uk>
Applied-Upstream: 1.8.15

--- a/doc/sudo.cat
+++ b/doc/sudo.cat
@@ -124,6 +124,13 @@ DDEESSCCRRIIPPTTIIOONN
                        copied back to their original location and the
                        temporary versions are removed.
 
+                 Unless explicitly allowed by the security policy, symbolic
+                 links will not be opened.  This helps prevent the editing of
+                 unauthorized files when the file is located in a user-
+                 writable directory.  Versions of ssuuddoo prior to
+                 1.8.10p3-1+deb8u3 do not have this restriction.  Users are
+                 never allowed to edit device special files.
+
                  If the specified file does not exist, it will be created.
                  Note that unlike most commands run by _s_u_d_o, the editor is run
                  with the invoking user's environment unmodified.  If, for
--- a/doc/sudo.man.in
+++ b/doc/sudo.man.in
@@ -292,6 +292,15 @@ their original location and the temporar
 .RE
 .RS 12n
 .sp
+Unless explicitly allowed by the security policy, symbolic links
+will not be opened.
+This helps prevent the editing of unauthorized files when the file
+is located in a user-writable directory.
+Versions of
+\fBsudo\fR
+prior to 1.8.10p3\-1+deb8u3 do not have this restriction.
+Users are never allowed to edit device special files.
+.sp
 If the specified file does not exist, it will be created.
 Note that unlike most commands run by
 \fIsudo\fR,
--- a/doc/sudo.mdoc.in
+++ b/doc/sudo.mdoc.in
@@ -265,6 +265,15 @@ If they have been modified, the temporar
 their original location and the temporary versions are removed.
 .El
 .Pp
+Unless explicitly allowed by the security policy, symbolic links
+will not be opened.
+This helps prevent the editing of unauthorized files when the file
+is located in a user-writable directory.
+Versions of
+.Nm
+prior to 1.8.10p3\-1+deb8u3 do not have this restriction.
+Users are never allowed to edit device special files.
+.Pp
 If the specified file does not exist, it will be created.
 Note that unlike most commands run by
 .Em sudo ,
--- a/doc/sudoers.cat
+++ b/doc/sudoers.cat
@@ -434,8 +434,8 @@ SSUUDDOOEERRSS FFIILLEE FFO
      Solaris_Priv_Spec ::= ('PRIVS=privset' | 'LIMITPRIVS=privset')
 
      Tag_Spec ::= ('NOPASSWD:' | 'PASSWD:' | 'NOEXEC:' | 'EXEC:' |
-                   'SETENV:' | 'NOSETENV:' | 'LOG_INPUT:' | 'NOLOG_INPUT:' |
-                   'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
+                   'SETENV:' | 'NOSETENV:' | 'FOLLOW:' | 'NOFOLLOW' |
+                   'LOG_INPUT:' | 'NOLOG_INPUT:' | 'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
 
      A uusseerr ssppeecciiffiiccaattiioonn determines which commands a user may run (and as
      what user) on specified hosts.  By default, commands are run as rroooott, but
@@ -550,10 +550,10 @@ SSUUDDOOEERRSS FFIILLEE FFO
    TTaagg__SSppeecc
      A command may have zero or more tags associated with it.  There are ten
      possible tag values: NOPASSWD, PASSWD, NOEXEC, EXEC, SETENV, NOSETENV,
-     LOG_INPUT, NOLOG_INPUT, LOG_OUTPUT and NOLOG_OUTPUT.  Once a tag is set
-     on a Cmnd, subsequent Cmnds in the Cmnd_Spec_List, inherit the tag unless
-     it is overridden by the opposite tag (in other words, PASSWD overrides
-     NOPASSWD and NOEXEC overrides EXEC).
+     FOLLOW, NOFOLLOW, LOG_INPUT, NOLOG_INPUT, LOG_OUTPUT and NOLOG_OUTPUT.
+     Once a tag is set on a Cmnd, subsequent Cmnds in the Cmnd_Spec_List,
+     inherit the tag unless it is overridden by the opposite tag (in other
+     words, PASSWD overrides NOPASSWD and NOEXEC overrides EXEC).
 
      _N_O_P_A_S_S_W_D and _P_A_S_S_W_D
 
@@ -596,6 +596,14 @@ SSUUDDOOEERRSS FFIILLEE FFO
        See the _P_r_e_v_e_n_t_i_n_g _s_h_e_l_l _e_s_c_a_p_e_s section below for more details on how
        NOEXEC works and whether or not it will work on your system.
 
+     _F_O_L_L_O_W and _N_O_F_O_L_L_O_W Starting with version 1.8.10p3-1+deb8u3, ssuuddooeeddiitt
+       will not follow symbolic links when opening files unless the
+       _s_u_d_o_e_d_i_t___f_o_l_l_o_w option is enabled.  The _F_O_L_L_O_W and _N_O_F_O_L_L_O_W tags
+       override the value of _s_u_d_o_e_d_i_t___f_o_l_l_o_w and can be used to permit (or deny)
+       the editing of symbolic links on a per-command basis.  These tags are
+       only effective for the _s_u_d_o_e_d_i_t command and are ignored for all
+       other commands.
+
      _S_E_T_E_N_V and _N_O_S_E_T_E_N_V
 
        These tags override the value of the _s_e_t_e_n_v option on a per-command
@@ -1194,6 +1202,15 @@ SSUUDDOOEERRSS OOPPTTIIOONN
                        that support either the setreuid(2) or setresuid(2)
                        system call.  This flag is _o_f_f by default.
 
+     sudoedit_follow   By default, ssuuddooeeddiitt will not follow symbolic links
+                       when opening files.  The _s_u_d_o_e_d_i_t___f_o_l_l_o_w option can be
+                       enabled to allow ssuuddooeeddiitt to open symbolic links.  It
+                       may be overridden on a per-command basis by the _F_O_L_L_O_W
+                       and _N_O_F_O_L_L_O_W tags.  This flag is _o_f_f by default.
+
+                       This setting is only supported by version
+                       1.8.10p3-1+deb8u3 or higher.
+
      targetpw          If set, ssuuddoo will prompt for the password of the user
                        specified by the --uu option (defaults to root) instead
                        of the password of the invoking user when running a
--- a/doc/sudoers.man.in
+++ b/doc/sudoers.man.in
@@ -895,8 +895,8 @@ SELinux_Spec ::= ('ROLE=role' | 'TYPE=ty
 Solaris_Priv_Spec ::= ('PRIVS=privset' | 'LIMITPRIVS=privset')
 
 Tag_Spec ::= ('NOPASSWD:' | 'PASSWD:' | 'NOEXEC:' | 'EXEC:' |
-              'SETENV:' | 'NOSETENV:' | 'LOG_INPUT:' | 'NOLOG_INPUT:' |
-              'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
+              'SETENV:' | 'NOSETENV:' | 'FOLLOW:' | 'NOFOLLOW' |
+              'LOG_INPUT:' | 'NOLOG_INPUT:' | 'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
 .RE
 .fi
 .PP
@@ -1153,6 +1153,8 @@ ten possible tag values:
 \fREXEC\fR,
 \fRSETENV\fR,
 \fRNOSETENV\fR,
+\fRFOLLOW\fR,
+\fRNOFOLLOW\fR,
 \fRLOG_INPUT\fR,
 \fRNOLOG_INPUT\fR,
 \fRLOG_OUTPUT\fR
@@ -1308,6 +1310,24 @@ tag is implied for that command; this de
 \fRNOSETENV\fR
 tag.
 .TP 2n
+\fIFOLLOW\fR and \fINOFOLLOW\fR
+Starting with version 1.8.10p3\-1+deb8u3,
+\fBsudoedit\fR
+will not follow symbolic links when opening files unless the
+\fIsudoedit_follow\fR
+option is enabled.
+The
+\fIFOLLOW\fR
+and
+\fINOFOLLOW\fR
+tags override the value of
+\fIsudoedit_follow\fR
+and can be used to permit (or deny) the editing of symbolic links
+on a per-command basis.
+These tags are only effective for the
+\fIsudoedit\fR
+command and are ignored for all other commands.
+.TP 2n
 \fILOG_INPUT\fR and \fINOLOG_INPUT\fR
 .sp
 These tags override the value of the
@@ -2526,6 +2546,26 @@ This flag is
 \fIoff\fR
 by default.
 .TP 18n
+sudoedit_follow
+By default,
+\fBsudoedit\fR
+will not follow symbolic links when opening files.
+The
+\fIsudoedit_follow\fR
+option can be enabled to allow
+\fBsudoedit\fR
+to open symbolic links.
+It may be overridden on a per-command basis by the
+\fIFOLLOW\fR
+and
+\fINOFOLLOW\fR
+tags.
+This flag is
+\fIoff\fR
+by default.
+.sp
+This setting is only supported by version 1.8.10p3\-1+deb8u3 or higher.
+.TP 18n
 targetpw
 If set,
 \fBsudo\fR
--- a/doc/sudoers.mdoc.in
+++ b/doc/sudoers.mdoc.in
@@ -851,8 +851,8 @@ SELinux_Spec ::= ('ROLE=role' | 'TYPE=ty
 Solaris_Priv_Spec ::= ('PRIVS=privset' | 'LIMITPRIVS=privset')
 
 Tag_Spec ::= ('NOPASSWD:' | 'PASSWD:' | 'NOEXEC:' | 'EXEC:' |
-              'SETENV:' | 'NOSETENV:' | 'LOG_INPUT:' | 'NOLOG_INPUT:' |
-              'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
+              'SETENV:' | 'NOSETENV:' | 'FOLLOW:' | 'NOFOLLOW' |
+              'LOG_INPUT:' | 'NOLOG_INPUT:' | 'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
 .Ed
 .Pp
 A
@@ -1079,6 +1079,8 @@ ten possible tag values:
 .Li EXEC ,
 .Li SETENV ,
 .Li NOSETENV ,
+.Li FOLLOW ,
+.Li NOFOLLOW ,
 .Li LOG_INPUT ,
 .Li NOLOG_INPUT ,
 .Li LOG_OUTPUT
@@ -1218,6 +1220,23 @@ the
 tag is implied for that command; this default may be overridden by use of the
 .Li NOSETENV
 tag.
+.It Em FOLLOW No and Em NOFOLLOW
+Starting with version 1.8.10p3\-1+deb8u3,
+.Nm sudoedit
+will not follow symbolic links when opening files unless the
+.Em sudoedit_follow
+option is enabled.
+The
+.Em FOLLOW
+and
+.Em NOFOLLOW
+tags override the value of
+.Em sudoedit_follow
+and can be used to permit (or deny) the editing of symbolic links
+on a per-command basis.
+These tags are only effective for the
+.Em sudoedit
+command and are ignored for all other commands.
 .It Em LOG_INPUT No and Em NOLOG_INPUT
 .sp
 These tags override the value of the
@@ -2364,6 +2383,25 @@ system call.
 This flag is
 .Em off
 by default.
+.It sudoedit_follow
+By default,
+.Nm sudoedit
+will not follow symbolic links when opening files.
+The
+.Em sudoedit_follow
+option can be enabled to allow
+.Nm sudoedit
+to open symbolic links.
+It may be overridden on a per-command basis by the
+.Em FOLLOW
+and
+.Em NOFOLLOW
+tags.
+This flag is
+.Em off
+by default.
+.Pp
+This setting is only supported by version 1.8.10p3\-1+deb8u3 or higher.
 .It targetpw
 If set,
 .Nm sudo
--- a/include/missing.h
+++ b/include/missing.h
@@ -185,6 +185,9 @@
 #ifndef S_ISDIR
 # define S_ISDIR(m)		(((m) & _S_IFMT) == _S_IFDIR)
 #endif /* S_ISDIR */
+#ifndef S_ISLNK
+# define S_ISLNK(m)		(((m) & _S_IFMT) == _S_IFLNK)
+#endif /* S_ISLNK */
 
 /*
  * Some OS's may not have this.
--- a/plugins/sudoers/def_data.in
+++ b/plugins/sudoers/def_data.in
@@ -283,3 +283,6 @@ maxseq
 use_netgroups
 	T_FLAG
 	"Enable sudoers netgroup support"
+sudoedit_follow
+	T_FLAG
+	"Follow symbolic links when editing files with sudoedit"
--- a/plugins/sudoers/gram.y
+++ b/plugins/sudoers/gram.y
@@ -128,6 +128,8 @@ static struct sudo_digest *new_digest(in
 %token <tok>	 NOLOG_INPUT		/* don't log user's cmnd input */
 %token <tok>	 LOG_OUTPUT		/* log cmnd output */
 %token <tok>	 NOLOG_OUTPUT		/* don't log cmnd output */
+%token <tok>	 FOLLOW			/* follow symbolic links */
+%token <tok>	 NOFOLLOW		/* don't follow symbolic links */
 %token <tok>	 ALL			/* ALL keyword */
 %token <tok>	 COMMENT		/* comment and/or carriage return */
 %token <tok>	 HOSTALIAS		/* Host_Alias keyword */
@@ -323,6 +325,8 @@ cmndspeclist	:	cmndspec
 				$3->tags.log_input = prev->tags.log_input;
 			    if ($3->tags.log_output == UNSPEC)
 				$3->tags.log_output = prev->tags.log_output;
+			    if ($3->tags.follow == UNSPEC)
+				$3->tags.follow = prev->tags.follow;
 			    if (($3->runasuserlist == NULL &&
 				 $3->runasgrouplist == NULL) &&
 				(prev->runasuserlist != NULL ||
@@ -504,8 +508,7 @@ runaslist	:	/* empty */ {
 		;
 
 cmndtag		:	/* empty */ {
-			    $$.nopasswd = $$.noexec = $$.setenv =
-				$$.log_input = $$.log_output = UNSPEC;
+			    TAGS_INIT($$);
 			}
 		|	cmndtag NOPASSWD {
 			    $$.nopasswd = true;
@@ -537,6 +540,12 @@ cmndtag		:	/* empty */ {
 		|	cmndtag NOLOG_OUTPUT {
 			    $$.log_output = false;
 			}
+		|	cmndtag FOLLOW {
+			    $$.follow = true;
+			}
+		|	cmndtag NOFOLLOW {
+			    $$.follow = false;
+			}
 		;
 
 cmnd		:	ALL {
--- a/plugins/sudoers/ldap.c
+++ b/plugins/sudoers/ldap.c
@@ -1868,6 +1868,9 @@ sudo_ldap_display_entry_short(LDAP *ld,
 	    if (strcmp(cp, "authenticate") == 0)
 		lbuf_append(lbuf, (*p)->bv_val[0] == '!' ?
 		    "NOPASSWD: " : "PASSWD: ");
+	    else if (strcmp(cp, "sudoedit_follow") == 0)
+		lbuf_append(lbuf, (*p)->bv_val[0] == '!' ?
+		    "FOLLOW: " : "NOFOLLOW: ");
 	    else if (strcmp(cp, "noexec") == 0)
 		lbuf_append(lbuf, (*p)->bv_val[0] == '!' ?
 		    "EXEC: " : "NOEXEC: ");
--- a/plugins/sudoers/parse.c
+++ b/plugins/sudoers/parse.c
@@ -271,6 +271,8 @@ sudo_file_lookup(struct sudo_nss *nss, i
 		def_log_input = tags->log_input;
 	    if (tags->log_output != UNSPEC)
 		def_log_output = tags->log_output;
+	    if (tags->follow != UNSPEC)
+		def_sudoedit_follow = tags->follow;
 	}
     } else if (match == DENY) {
 	SET(validated, VALIDATE_NOT_OK);
@@ -282,9 +284,6 @@ sudo_file_lookup(struct sudo_nss *nss, i
     debug_return_int(validated);
 }
 
-#define	TAG_SET(tt) \
-	((tt) != UNSPEC && (tt) != IMPLIED)
-
 #define	TAG_CHANGED(t) \
 	(TAG_SET(cs->tags.t) && cs->tags.t != tags->t)
 
@@ -326,15 +325,14 @@ sudo_file_append_cmnd(struct cmndspec *c
 	lbuf_append(lbuf, cs->tags.log_output ? "LOG_OUTPUT: " : "NOLOG_OUTPUT: ");
 	tags->log_output = cs->tags.log_output;
     }
+    if (TAG_CHANGED(follow)) {
+	tags->follow = cs->tags.follow;
+	lbuf_append(lbuf, tags->follow ? "FOLLOW: " : "NOFOLLOW: ");
+    }
     print_member(lbuf, cs->cmnd, CMNDALIAS);
     debug_return;
 }
 
-#define	RUNAS_CHANGED(cs1, cs2) \
-	(cs1 == NULL || cs2 == NULL || \
-	 cs1->runasuserlist != cs2->runasuserlist || \
-	 cs1->runasgrouplist != cs2->runasgrouplist)
-
 static int
 sudo_file_display_priv_short(struct passwd *pw, struct userspec *us,
     struct lbuf *lbuf)
@@ -347,11 +345,7 @@ sudo_file_display_priv_short(struct pass
     debug_decl(sudo_file_display_priv_short, SUDO_DEBUG_NSS)
 
     /* gcc -Wuninitialized false positive */
-    tags.noexec = UNSPEC;
-    tags.setenv = UNSPEC;
-    tags.nopasswd = UNSPEC;
-    tags.log_input = UNSPEC;
-    tags.log_output = UNSPEC;
+    TAGS_INIT(tags);
     TAILQ_FOREACH(priv, &us->privileges, entries) {
 	if (hostlist_matches(&priv->hostlist) != ALLOW)
 	    continue;
@@ -381,11 +375,7 @@ sudo_file_display_priv_short(struct pass
 		    }
 		}
 		lbuf_append(lbuf, ") ");
-		tags.noexec = UNSPEC;
-		tags.setenv = UNSPEC;
-		tags.nopasswd = UNSPEC;
-		tags.log_input = UNSPEC;
-		tags.log_output = UNSPEC;
+		TAGS_INIT(tags);
 	    } else if (cs != TAILQ_FIRST(&priv->cmndlist)) {
 		lbuf_append(lbuf, ", ");
 	    }
@@ -398,13 +388,6 @@ sudo_file_display_priv_short(struct pass
     debug_return_int(nfound);
 }
 
-#define	TAGS_CHANGED(ot, nt) \
-	((TAG_SET((nt).setenv) && (nt).setenv != (ot).setenv) || \
-	 (TAG_SET((nt).noexec) && (nt).noexec != (ot).noexec) || \
-	 (TAG_SET((nt).nopasswd) && (nt).nopasswd != (ot).nopasswd) || \
-	 (TAG_SET((nt).log_input) && (nt).log_input != (ot).log_input) || \
-	 (TAG_SET((nt).log_output) && (nt).log_output != (ot).log_output))
-
 /*
  * Compare the current cmndspec with the previous one to determine
  * whether we need to start a new long entry for "sudo -ll".
--- a/plugins/sudoers/parse.h
+++ b/plugins/sudoers/parse.h
@@ -27,6 +27,51 @@
 #undef IMPLIED
 #define IMPLIED	 2
 
+/*
+ * Initialize all tags to UNSPEC.
+ */
+#define TAGS_INIT(t)	do {						       \
+    (t).follow = UNSPEC;						       \
+    (t).log_input = UNSPEC;						       \
+    (t).log_output = UNSPEC;						       \
+    (t).noexec = UNSPEC;						       \
+    (t).nopasswd = UNSPEC;						       \
+    (t).setenv = UNSPEC;						       \
+} while (0)
+
+/*
+ * Returns true if any tag are not UNSPEC, else false.
+ */
+#define TAGS_SET(t)							       \
+    ((t).follow != UNSPEC || (t).log_input != UNSPEC ||			       \
+     (t).log_output != UNSPEC || (t).noexec != UNSPEC ||		       \
+     (t).nopasswd != UNSPEC || (t).setenv != UNSPEC)
+
+/*
+ * Returns true if the specified tag is not UNSPEC or IMPLIED, else false.
+ */
+#define TAG_SET(tt) \
+    ((tt) != UNSPEC && (tt) != IMPLIED)
+
+/*
+ * Returns true if any tags set in nt differ between ot and nt, else false.
+ */
+#define TAGS_CHANGED(ot, nt) \
+    ((TAG_SET((nt).follow) && (nt).follow != (ot).follow) || \
+    (TAG_SET((nt).log_input) && (nt).log_input != (ot).log_input) || \
+    (TAG_SET((nt).log_output) && (nt).log_output != (ot).log_output) || \
+    (TAG_SET((nt).noexec) && (nt).noexec != (ot).noexec) || \
+    (TAG_SET((nt).nopasswd) && (nt).nopasswd != (ot).nopasswd) || \
+    (TAG_SET((nt).setenv) && (nt).setenv != (ot).setenv))
+
+/*
+ * Returns true if the runas user and group lists match, else false.
+ */
+#define RUNAS_CHANGED(cs1, cs2) \
+    ((cs1) == NULL || (cs2) == NULL || \
+     (cs1)->runasuserlist != (cs2)->runasuserlist || \
+     (cs1)->runasgrouplist != (cs2)->runasgrouplist)
+
 #define SUDO_DIGEST_SHA224	0
 #define SUDO_DIGEST_SHA256	1
 #define SUDO_DIGEST_SHA384	2
@@ -58,6 +103,7 @@ struct cmndtag {
     signed int setenv: 3;
     signed int log_input: 3;
     signed int log_output: 3;
+    signed int follow: 3;
 };
 
 /*
--- a/plugins/sudoers/policy.c
+++ b/plugins/sudoers/policy.c
@@ -395,8 +395,11 @@ sudoers_policy_exec_setup(char *argv[],
 	    easprintf(&command_info[info_len++], "maxseq=%u", def_maxseq);
 	}
     }
-    if (ISSET(sudo_mode, MODE_EDIT))
+    if (ISSET(sudo_mode, MODE_EDIT)) {
 	command_info[info_len++] = estrdup("sudoedit=true");
+	if (def_sudoedit_follow)
+	    command_info[info_len++] = estrdup("sudoedit_follow=true");
+    }
     if (ISSET(sudo_mode, MODE_LOGIN_SHELL)) {
 	/* Set cwd to run user's homedir. */
 	command_info[info_len++] = fmt_string("cwd", runas_pw->pw_dir);
--- a/plugins/sudoers/regress/sudoers/test1.in
+++ b/plugins/sudoers/regress/sudoers/test1.in
@@ -6,3 +6,5 @@ user1 ALL = LOG_INPUT: LOG_OUTPUT: /usr/
       ALL = NOLOG_INPUT: NOLOG_OUTPUT: /usr/bin/id
 user2 ALL = NOPASSWD: NOEXEC: SETENV: /usr/bin/vi:\
       ALL = PASSWD: EXEC: NOSETENV: /usr/bin/echo
+user4 ALL = FOLLOW: sudoedit /etc/motd:\
+      ALL = NOFOLLOW: sudoedit /home/*/*
--- a/plugins/sudoers/regress/sudoers/test1.out.ok
+++ b/plugins/sudoers/regress/sudoers/test1.out.ok
@@ -4,3 +4,4 @@ Parses OK.
 
 user1	ALL = /usr/bin/su - : ALL = /usr/bin/id
 user2	ALL = NOPASSWD: NOEXEC: /usr/bin/vi : ALL = PASSWD: EXEC: /usr/bin/echo
+user4	ALL = FOLLOW: sudoedit /etc/motd : ALL = NOFOLLOW: sudoedit /home/*/*
--- a/plugins/sudoers/regress/sudoers/test1.toke.ok
+++ b/plugins/sudoers/regress/sudoers/test1.toke.ok
@@ -4,3 +4,4 @@
 #
 WORD(5) ALL = LOG_INPUT LOG_OUTPUT COMMAND ARG : ALL = NOLOG_INPUT NOLOG_OUTPUT COMMAND 
 WORD(5) ALL = NOPASSWD NOEXEC SETENV COMMAND : ALL = PASSWD EXEC NOSETENV COMMAND 
+WORD(5) ALL = FOLLOW COMMAND ARG : ALL = NOFOLLOW COMMAND ARG 
--- a/plugins/sudoers/testsudoers.c
+++ b/plugins/sudoers/testsudoers.c
@@ -586,8 +586,7 @@ print_privilege(struct privilege *priv)
 	print_member(m);
     }
     fputs(" = ", stdout);
-    tags.nopasswd = UNSPEC;
-    tags.noexec = UNSPEC;
+    TAGS_INIT(tags);
     TAILQ_FOREACH(cs, &priv->cmndlist, entries) {
 	if (cs != TAILQ_FIRST(&priv->cmndlist))
 	    fputs(", ", stdout);
@@ -626,6 +625,8 @@ print_privilege(struct privilege *priv)
 	if (cs->limitprivs)
 	    printf("LIMITPRIVS=%s ", cs->limitprivs);
 #endif /* HAVE_PRIV_SET */
+	if (cs->tags.follow != UNSPEC && cs->tags.follow != tags.follow)
+	    printf("%sFOLLOW: ", cs->tags.follow ? "" : "NO");
 	if (cs->tags.nopasswd != UNSPEC && cs->tags.nopasswd != tags.nopasswd)
 	    printf("%sPASSWD: ", cs->tags.nopasswd ? "NO" : "");
 	if (cs->tags.noexec != UNSPEC && cs->tags.noexec != tags.noexec)
--- a/plugins/sudoers/toke.l
+++ b/plugins/sudoers/toke.l
@@ -461,6 +461,16 @@ NOLOG_INPUT[[:blank:]]*:	{
 			    	LEXRETURN(NOLOG_INPUT);
 			}
 
+FOLLOW[[:blank:]]*:	{
+			    	LEXTRACE("FOLLOW ");
+			    	LEXRETURN(FOLLOW);
+			}
+
+NOFOLLOW[[:blank:]]*:	{
+			    	LEXTRACE("NOFOLLOW ");
+			    	LEXRETURN(NOFOLLOW);
+			}
+
 <INITIAL,GOTDEFS>(\+|\%|\%:) {
 			    /* empty group or netgroup */
 			    LEXTRACE("ERROR ");
--- a/plugins/sudoers/visudo_json.c
+++ b/plugins/sudoers/visudo_json.c
@@ -747,22 +747,6 @@ print_aliases_json(FILE *fp, int indent,
     debug_return_bool(need_comma);
 }
 
-/* XXX these are all duplicated w/ parse.c */
-#define RUNAS_CHANGED(cs1, cs2) \
-	(cs1 == NULL || cs2 == NULL || \
-	 cs1->runasuserlist != cs2->runasuserlist || \
-	 cs1->runasgrouplist != cs2->runasgrouplist)
-
-#define TAG_SET(tt) \
-	((tt) != UNSPEC && (tt) != IMPLIED)
-
-#define TAGS_CHANGED(ot, nt) \
-	((TAG_SET((nt).setenv) && (nt).setenv != (ot).setenv) || \
-	 (TAG_SET((nt).noexec) && (nt).noexec != (ot).noexec) || \
-	 (TAG_SET((nt).nopasswd) && (nt).nopasswd != (ot).nopasswd) || \
-	 (TAG_SET((nt).log_input) && (nt).log_input != (ot).log_input) || \
-	 (TAG_SET((nt).log_output) && (nt).log_output != (ot).log_output))
-
 /*
  * Print a Cmnd_Spec in JSON format at the specified indent level.
  * A pointer to the next Cmnd_Spec is passed in to make it possible to
@@ -807,47 +791,52 @@ print_cmndspec_json(FILE *fp, struct cmn
     }
 
     /* Print tags */
-    if (cs->tags.nopasswd != UNSPEC || cs->tags.noexec != UNSPEC ||
-	cs->tags.setenv != UNSPEC || cs->tags.log_input != UNSPEC ||
-	cs->tags.log_output != UNSPEC) {
+    if (TAGS_SET(cs->tags)) {
+	struct cmndtag tag = cs->tags;
+
 	fprintf(fp, "%*s\"Options\": [\n", indent, "");
 	indent += 4;
-	if (cs->tags.nopasswd != UNSPEC) {
+	if (tag.nopasswd != UNSPEC) {
 	    value.type = JSON_BOOL;
-	    value.u.boolean = !cs->tags.nopasswd;
-	    last_one = cs->tags.noexec == UNSPEC &&
-		cs->tags.setenv == UNSPEC && cs->tags.log_input == UNSPEC &&
-		cs->tags.log_output == UNSPEC;
+	    value.u.boolean = !tag.nopasswd;
+	    tag.nopasswd = UNSPEC;
 	    print_pair_json(fp, "{ ", "authenticate", &value,
-		last_one ? " }\n" : " },\n", indent);
+		TAGS_SET(tag) ? " },\n" : " }\n", indent);
 	}
-	if (cs->tags.noexec != UNSPEC) {
+	if (tag.noexec != UNSPEC) {
 	    value.type = JSON_BOOL;
-	    value.u.boolean = cs->tags.noexec;
-	    last_one = cs->tags.setenv == UNSPEC &&
-		cs->tags.log_input == UNSPEC && cs->tags.log_output == UNSPEC;
+	    value.u.boolean = tag.noexec;
+	    tag.noexec = UNSPEC;
 	    print_pair_json(fp, "{ ", "noexec", &value,
-		last_one ? " }\n" : " },\n", indent);
+		TAGS_SET(tag) ? " },\n" : " }\n", indent);
 	}
-	if (cs->tags.setenv != UNSPEC) {
+	if (tag.setenv != UNSPEC) {
 	    value.type = JSON_BOOL;
-	    value.u.boolean = cs->tags.setenv;
-	    last_one = cs->tags.log_input == UNSPEC &&
-		cs->tags.log_output == UNSPEC;
+	    value.u.boolean = tag.setenv;
+	    tag.setenv = UNSPEC;
 	    print_pair_json(fp, "{ ", "setenv", &value,
-		last_one ? " }\n" : " },\n", indent);
+		TAGS_SET(tag) ? " },\n" : " }\n", indent);
+	}
+	if (tag.follow != UNSPEC) {
+	    value.type = JSON_BOOL;
+	    value.u.boolean = tag.follow;
+	    tag.follow = UNSPEC;
+	    print_pair_json(fp, "{ ", "sudoedit_follow", &value,
+		TAGS_SET(tag) ? " },\n" : " }\n", indent);
 	}
-	if (cs->tags.log_input != UNSPEC) {
+	if (tag.log_input != UNSPEC) {
 	    value.type = JSON_BOOL;
-	    value.u.boolean = cs->tags.log_input;
-	    last_one = cs->tags.log_output == UNSPEC;
+	    value.u.boolean = tag.log_input;
+	    tag.log_input = UNSPEC;
 	    print_pair_json(fp, "{ ", "log_input", &value,
-		last_one ? " }\n" : " },\n", indent);
+		TAGS_SET(tag) ? " },\n" : " }\n", indent);
 	}
-	if (cs->tags.log_output != UNSPEC) {
+	if (tag.log_output != UNSPEC) {
 	    value.type = JSON_BOOL;
-	    value.u.boolean = cs->tags.log_output;
-	    print_pair_json(fp, "{ ", "log_output", &value, " }\n", indent);
+	    value.u.boolean = tag.log_output;
+	    tag.log_output = UNSPEC;
+	    print_pair_json(fp, "{ ", "log_output", &value,
+		TAGS_SET(tag) ? " },\n" : " }\n", indent);
 	}
 	indent -= 4;
 	fprintf(fp, "%*s],\n", indent, "");
--- a/src/sudo.c
+++ b/src/sudo.c
@@ -676,6 +676,11 @@ command_info_to_details(char * const inf
 			SET(details->flags, CD_SUDOEDIT);
 		    break;
 		}
+		if (strncmp("sudoedit_follow=", info[i], sizeof("sudoedit_follow=") - 1) == 0) {
+		    if (atobool(info[i] + sizeof("sudoedit_follow=") - 1) == true)
+			SET(details->flags, CD_SUDOEDIT_FOLLOW);
+		    break;
+		}
 		break;
 	    case 't':
 		if (strncmp("timeout=", info[i], sizeof("timeout=") - 1) == 0) {
--- a/src/sudo.h
+++ b/src/sudo.h
@@ -107,21 +107,22 @@ struct user_details {
     int ts_lines;
 };
 
-#define CD_SET_UID		0x0001
-#define CD_SET_EUID		0x0002
-#define CD_SET_GID		0x0004
-#define CD_SET_EGID		0x0008
-#define CD_PRESERVE_GROUPS	0x0010
-#define CD_NOEXEC		0x0020
-#define CD_SET_PRIORITY		0x0040
-#define CD_SET_UMASK		0x0080
-#define CD_SET_TIMEOUT		0x0100
-#define CD_SUDOEDIT		0x0200
-#define CD_BACKGROUND		0x0400
-#define CD_RBAC_ENABLED		0x0800
-#define CD_USE_PTY		0x1000
-#define CD_SET_UTMP		0x2000
-#define CD_EXEC_BG		0x4000
+#define CD_SET_UID		0x00001
+#define CD_SET_EUID		0x00002
+#define CD_SET_GID		0x00004
+#define CD_SET_EGID		0x00008
+#define CD_PRESERVE_GROUPS	0x00010
+#define CD_NOEXEC		0x00020
+#define CD_SET_PRIORITY		0x00040
+#define CD_SET_UMASK		0x00080
+#define CD_SET_TIMEOUT		0x00100
+#define CD_SUDOEDIT		0x00200
+#define CD_BACKGROUND		0x00400
+#define CD_RBAC_ENABLED		0x00800
+#define CD_USE_PTY		0x01000
+#define CD_SET_UTMP		0x02000
+#define CD_EXEC_BG		0x04000
+#define CD_SUDOEDIT_FOLLOW	0x10000
 
 struct preserved_fd {
     TAILQ_ENTRY(preserved_fd) entries;
--- a/src/sudo_edit.c
+++ b/src/sudo_edit.c
@@ -79,6 +79,50 @@ switch_user(uid_t euid, gid_t egid, int
     debug_return;
 }
 
+#ifdef O_NOFOLLOW
+static int
+sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+{
+    if (!ISSET(sflags, CD_SUDOEDIT_FOLLOW))
+	oflags |= O_NOFOLLOW;
+    return open(path, oflags, mode);
+}
+#else
+static int
+sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+{
+    struct stat sb1, sb2;
+    int fd;
+
+    fd = open(path, oflags, mode);
+    if (fd == -1 || ISSET(sflags, CD_SUDOEDIT_FOLLOW))
+	return fd;
+
+    /*
+     * Treat [fl]stat() failure like an open() failure.
+     */
+    if (fstat(fd, &sb1) == -1 || lstat(path, &sb2) == -1) {
+	const int serrno = errno;
+	close(fd);
+	errno = serrno;
+	return -1;
+    }
+
+    /*
+     * Make sure we did not open a link and that what we opened
+     * matches what is currently on the file system.
+     */
+    if (S_ISLNK(sb2.st_mode) ||
+	sb1.st_dev != sb2.st_dev || sb1.st_ino != sb2.st_ino) {
+	close(fd);
+	errno = ELOOP;
+	return -1;
+    }
+
+    return fd;
+}
+#endif /* O_NOFOLLOW */
+
 /*
  * Wrapper to allow users to edit privileged files with their own uid.
  */
@@ -153,7 +197,8 @@ sudo_edit(struct command_details *comman
 	rc = -1;
 	switch_user(command_details->euid, command_details->egid,
 	    command_details->ngroups, command_details->groups);
-	if ((ofd = open(files[i], O_RDONLY, 0644)) != -1 || errno == ENOENT) {
+	ofd = sudo_edit_open(files[i], O_RDONLY, 0644, command_details->flags);
+	if (ofd != -1 || errno == ENOENT) {
 	    if (ofd == -1) {
 		memset(&sb, 0, sizeof(sb));		/* new file */
 		rc = 0;
@@ -163,11 +208,17 @@ sudo_edit(struct command_details *comman
 	}
 	switch_user(ROOT_UID, user_details.egid,
 	    user_details.ngroups, user_details.groups);
-	if (rc || (ofd != -1 && !S_ISREG(sb.st_mode))) {
-	    if (rc)
-		warning("%s", files[i]);
+	if (ofd != -1 && !S_ISREG(sb.st_mode)) {
+	    warningx(U_("%s: not a regular file"), files[i]);
+	    close(ofd);
+	    continue;
+	}
+	if (rc == -1) {
+	    /* open() or fstat() error. */
+	    if (ofd == -1 && errno == ELOOP)
+		warningx(U_("%s: is a symbolic link"), files[i]);
 	    else
-		warningx(U_("%s: not a regular file"), files[i]);
+		warning("%s", files[i]);
 	    if (ofd != -1)
 		close(ofd);
 	    continue;
@@ -258,9 +309,9 @@ sudo_edit(struct command_details *comman
 	rc = -1;
 	if (seteuid(user_details.uid) != 0)
 	    fatal("seteuid(%d)", (int)user_details.uid);
-	if ((tfd = open(tf[i].tfile, O_RDONLY, 0644)) != -1) {
+	tfd = sudo_edit_open(tf[i].tfile, O_RDONLY, 0644, 0);
+	if (tfd != -1)
 	    rc = fstat(tfd, &sb);
-	}
 	if (seteuid(ROOT_UID) != 0)
 	    fatal("seteuid(ROOT_UID)");
 	if (rc || !S_ISREG(sb.st_mode)) {
@@ -288,7 +339,8 @@ sudo_edit(struct command_details *comman
 	}
 	switch_user(command_details->euid, command_details->egid,
 	    command_details->ngroups, command_details->groups);
-	ofd = open(tf[i].ofile, O_WRONLY|O_TRUNC|O_CREAT, 0644);
+	ofd = sudo_edit_open(tf[i].ofile, O_WRONLY|O_TRUNC|O_CREAT, 0644,
+	    command_details->flags);
 	switch_user(ROOT_UID, user_details.egid,
 	    user_details.ngroups, user_details.groups);
 	if (ofd == -1) {
