Description: CVE-2015-5602: sudoedit path restriction bypass using symlinks
 Do not follow symbolic links in sudoedit by default.  This behavior
 can be controlled by the sudoedit_follow Defaults flag as well as
 the FOLLOW/NOFOLLOW tags.
Origin: backport, https://www.sudo.ws/repos/sudo/rev/9636fd256325
Bug: https://bugzilla.sudo.ws/show_bug.cgi?id=707
Bug-Debian: https://bugs.debian.org/804149
Author: Todd C. Miller <Todd.Miller@courtesan.com>
Author: Ben Hutchings <ben@decadent.org.uk>
Applied-Upstream: 1.8.15

--- a/sudo.pod
+++ b/sudo.pod
@@ -190,6 +190,14 @@ their original location and the temporar
 
 =back
 
+Unless explicitly allowed by the security policy, symbolic links
+will not be opened.
+This helps prevent the editing of unauthorized files when the file
+is located in a user-writable directory.
+Versions of B<sudo> prior to 1.7.4p4-2.squeeze.6 do not have this
+restriction.
+Users are never allowed to edit device special files.
+
 If the specified file does not exist, it will be created.  Note
 that unlike most commands run by B<sudo>, the editor is run with
 the invoking user's environment unmodified.  If, for some reason,
--- a/sudoers.pod
+++ b/sudoers.pod
@@ -286,8 +286,8 @@ See L<"SUDOERS OPTIONS"> for a list of s
  SELinux_Spec ::= ('ROLE=role' | 'TYPE=type')
 
  Tag_Spec ::= ('NOPASSWD:' | 'PASSWD:' | 'NOEXEC:' | 'EXEC:' |
-	       'SETENV:' | 'NOSETENV:' | 'LOG_INPUT:' | 'NOLOG_INPUT:' |
-               'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
+              'SETENV:' | 'NOSETENV:' | 'FOLLOW:' | 'NOFOLLOW' |
+              'LOG_INPUT:' | 'NOLOG_INPUT:' | 'LOG_OUTPUT:' | 'NOLOG_OUTPUT:')
 
 A B<user specification> determines which commands a user may run
 (and as what user) on specified hosts.  By default, commands are
@@ -357,7 +357,8 @@ however, will supercede the values in I<
 
 A command may have zero or more tags associated with it.  There are
 eight possible tag values, C<NOPASSWD>, C<PASSWD>, C<NOEXEC>,
-C<EXEC>, C<SETENV>, C<NOSETENV>, C<LOG_INPUT>, C<NOLOG_INPUT>,
+C<EXEC>, C<SETENV>, C<NOSETENV>, C<FOLLOW>, C<NOFOLLOW>, C<LOG_INPUT>,
+C<NOLOG_INPUT>,
 C<LOG_OUTPUT> and C<NOLOG_OUTPUT>.  Once a tag is set on a C<Cmnd>,
 subsequent C<Cmnd>s in the C<Cmnd_Spec_List>, inherit the tag unless
 it is overridden by the opposite tag (i.e.: C<PASSWD> overrides
@@ -416,6 +417,15 @@ variables in this manner.  If the comman
 C<SETENV> tag is implied for that command; this default may
 be overridden by use of the C<NOSETENV> tag.
 
+=head3 FOLLOW and NOFOLLOW
+
+Starting with version 1.7.4p4-2.squeeze.6, B<sudoedit> will not follow symbolic
+links when opening files unless the I<sudoedit_follow> option is
+enabled.  The C<FOLLOW> and C<NOFOLLOW> tags override the value of
+I<sudoedit_follow> and can be used to permit (or deny) the editing of
+symbolic links on a per-command basis.  These tags are only effective
+for the I<sudoedit> command and are ignored for all other commands.
+
 =head3 LOG_INPUT and NOLOG_INPUT
 
 These tags override the value of the I<log_input> option on a
@@ -865,6 +875,16 @@ dangerous functionality when a program i
 is only effective on systems with either the setreuid() or setresuid()
 function.  This flag is I<off> by default.
 
+=item sudoedit_follow
+
+By default, B<sudoedit> will not follow symbolic links when opening
+files.  The I<sudoedit_follow> option can be enabled to allow
+B<sudoedit> to open symbolic links.  It may be overridden on a
+per-command basis by the I<FOLLOW> and I<NOFOLLOW> tags.  This flag
+is I<off> by default.
+
+This setting is only supported by version 1.7.4p4-2.squeeze.6 or higher.
+
 =item targetpw
 
 If set, B<sudo> will prompt for the password of the user specified
--- a/compat.h
+++ b/compat.h
@@ -106,6 +106,9 @@
 #ifndef S_ISDIR
 # define S_ISDIR(m)		(((m) & _S_IFMT) == _S_IFDIR)
 #endif /* S_ISDIR */
+#ifndef S_ISLNK
+# define S_ISLNK(m)		(((m) & _S_IFMT) == _S_IFLNK)
+#endif /* S_ISLNK */
 
 /*
  * Some OS's may not have this.
--- a/def_data.in
+++ b/def_data.in
@@ -244,3 +244,6 @@ compress_io
 use_pty
 	T_FLAG
 	"Always run commands in a pseudo-tty"
+sudoedit_follow
+	T_FLAG
+	"Follow symbolic links when editing files with sudoedit"
--- a/gram.y
+++ b/gram.y
@@ -145,6 +145,8 @@ yyerror(s)
 %token <tok>	 NOLOG_INPUT		/* don't log user's cmnd input */
 %token <tok>	 LOG_OUTPUT		/* log cmnd output */
 %token <tok>	 NOLOG_OUTPUT		/* don't log cmnd output */
+%token <tok>	 FOLLOW			/* follow symbolic links */
+%token <tok>	 NOFOLLOW		/* don't follow symbolic links */
 %token <tok>	 ALL			/* ALL keyword */
 %token <tok>	 COMMENT		/* comment and/or carriage return */
 %token <tok>	 HOSTALIAS		/* Host_Alias keyword */
@@ -320,6 +322,8 @@ cmndspeclist	:	cmndspec
 				$3->tags.log_input = $3->prev->tags.log_input;
 			    if ($3->tags.log_output == UNSPEC)
 				$3->tags.log_output = $3->prev->tags.log_output;
+			    if ($3->tags.follow == UNSPEC)
+				$3->tags.follow = $3->prev->tags.follow;
 			    if ((tq_empty(&$3->runasuserlist) &&
 				 tq_empty(&$3->runasgrouplist)) &&
 				(!tq_empty(&$3->prev->runasuserlist) ||
@@ -425,8 +429,7 @@ runaslist	:	userlist {
 		;
 
 cmndtag		:	/* empty */ {
-			    $$.nopasswd = $$.noexec = $$.setenv =
-				$$.log_input = $$.log_output = UNSPEC;
+			    TAGS_INIT($$);
 			}
 		|	cmndtag NOPASSWD {
 			    $$.nopasswd = TRUE;
@@ -458,6 +461,12 @@ cmndtag		:	/* empty */ {
 		|	cmndtag NOLOG_OUTPUT {
 			    $$.log_output = FALSE;
 			}
+		|	cmndtag FOLLOW {
+			    $$.follow = TRUE;
+			}
+		|	cmndtag NOFOLLOW {
+			    $$.follow = FALSE;
+			}
 		;
 
 cmnd		:	ALL {
--- a/ldap.c
+++ b/ldap.c
@@ -1321,6 +1321,9 @@ sudo_ldap_display_entry_short(ld, entry,
 	    if (strcmp(cp, "authenticate") == 0)
 		tag = (*p)->bv_val[0] == '!' ?
 		    "NOPASSWD: " : "PASSWD: ";
+	    else if (strcmp(cp, "sudoedit_follow") == 0)
+		tag = (*p)->bv_val[0] == '!' ?
+		    "FOLLOW: " : "NOFOLLOW: ";
 	    else if (strcmp(cp, "noexec") == 0)
 		tag = (*p)->bv_val[0] == '!' ?
 		    "EXEC: " : "NOEXEC: ";
--- a/parse.c
+++ b/parse.c
@@ -253,6 +253,8 @@ sudo_file_lookup(nss, validated, pwflag)
 		def_log_input = tags->log_input;
 	    if (tags->log_output != UNSPEC)
 		def_log_output = tags->log_output;
+	    if (tags->follow != UNSPEC)
+		def_sudoedit_follow = tags->follow;
 	}
     } else if (match == DENY) {
 	SET(validated, VALIDATE_NOT_OK);
@@ -304,6 +306,10 @@ sudo_file_append_cmnd(cs, tags, lbuf)
 	    "NOLOG_OUTPUT: ", NULL);
 	tags->log_output = cs->tags.log_output;
     }
+    if (TAG_CHANGED(follow)) {
+	tags->follow = cs->tags.follow;
+	lbuf_append(lbuf, tags->follow ? "FOLLOW: " : "NOFOLLOW: ", NULL);
+    }
     m = cs->cmnd;
     print_member(lbuf, m->name, m->type, m->negated,
 	CMNDALIAS);
@@ -324,11 +330,7 @@ sudo_file_display_priv_short(pw, us, lbu
     tq_foreach_fwd(&us->privileges, priv) {
 	if (hostlist_matches(&priv->hostlist) != ALLOW)
 	    continue;
-	tags.noexec = UNSPEC;
-	tags.setenv = UNSPEC;
-	tags.nopasswd = UNSPEC;
-	tags.log_input = UNSPEC;
-	tags.log_output = UNSPEC;
+	TAGS_INIT(tags);
 	lbuf_append(lbuf, "    ", NULL);
 	tq_foreach_fwd(&priv->cmndlist, cs) {
 	    if (cs != tq_first(&priv->cmndlist))
@@ -379,11 +381,7 @@ sudo_file_display_priv_long(pw, us, lbuf
     tq_foreach_fwd(&us->privileges, priv) {
 	if (hostlist_matches(&priv->hostlist) != ALLOW)
 	    continue;
-	tags.noexec = UNSPEC;
-	tags.setenv = UNSPEC;
-	tags.nopasswd = UNSPEC;
-	tags.log_input = UNSPEC;
-	tags.log_output = UNSPEC;
+	TAGS_INIT(tags);
 	lbuf_append(lbuf, "\nSudoers entry:\n", NULL);
 	tq_foreach_fwd(&priv->cmndlist, cs) {
 	    lbuf_append(lbuf, "    RunAsUsers: ", NULL);
--- a/parse.h
+++ b/parse.h
@@ -28,6 +28,51 @@
 #define IMPLIED	 2
 
 /*
+ * Initialize all tags to UNSPEC.
+ */
+#define TAGS_INIT(t)	do {						       \
+    (t).follow = UNSPEC;						       \
+    (t).log_input = UNSPEC;						       \
+    (t).log_output = UNSPEC;						       \
+    (t).noexec = UNSPEC;						       \
+    (t).nopasswd = UNSPEC;						       \
+    (t).setenv = UNSPEC;						       \
+} while (0)
+
+/*
+ * Returns true if any tag are not UNSPEC, else false.
+ */
+#define TAGS_SET(t)							       \
+    ((t).follow != UNSPEC || (t).log_input != UNSPEC ||			       \
+     (t).log_output != UNSPEC || (t).noexec != UNSPEC ||		       \
+     (t).nopasswd != UNSPEC || (t).setenv != UNSPEC)
+
+/*
+ * Returns true if the specified tag is not UNSPEC or IMPLIED, else false.
+ */
+#define TAG_SET(tt) \
+    ((tt) != UNSPEC && (tt) != IMPLIED)
+
+/*
+ * Returns true if any tags set in nt differ between ot and nt, else false.
+ */
+#define TAGS_CHANGED(ot, nt) \
+    ((TAG_SET((nt).follow) && (nt).follow != (ot).follow) || \
+    (TAG_SET((nt).log_input) && (nt).log_input != (ot).log_input) || \
+    (TAG_SET((nt).log_output) && (nt).log_output != (ot).log_output) || \
+    (TAG_SET((nt).noexec) && (nt).noexec != (ot).noexec) || \
+    (TAG_SET((nt).nopasswd) && (nt).nopasswd != (ot).nopasswd) || \
+    (TAG_SET((nt).setenv) && (nt).setenv != (ot).setenv))
+
+/*
+ * Returns true if the runas user and group lists match, else false.
+ */
+#define RUNAS_CHANGED(cs1, cs2) \
+    ((cs1) == NULL || (cs2) == NULL || \
+     (cs1)->runasuserlist != (cs2)->runasuserlist || \
+     (cs1)->runasgrouplist != (cs2)->runasgrouplist)
+
+/*
  * A command with args. XXX - merge into struct member.
  */
 struct sudo_command {
@@ -45,6 +90,7 @@ struct cmndtag {
     __signed int setenv: 3;
     __signed int log_input: 3;
     __signed int log_output: 3;
+    signed int follow: 3;
 };
 
 /*
--- a/testsudoers.c
+++ b/testsudoers.c
@@ -486,7 +486,7 @@ print_privilege(priv)
 	    print_member(m);
 	}
 	fputs(" = ", stdout);
-	tags.nopasswd = tags.noexec = UNSPEC;
+	TAGS_INIT(tags);
 	tq_foreach_fwd(&p->cmndlist, cs) {
 	    if (cs != tq_first(&p->cmndlist))
 		fputs(", ", stdout);
@@ -510,6 +510,8 @@ print_privilege(priv)
 		printf("%sPASSWD: ", cs->tags.nopasswd ? "NO" : "");
 	    if (cs->tags.noexec != UNSPEC && cs->tags.noexec != tags.noexec)
 		printf("%sEXEC: ", cs->tags.noexec ? "NO" : "");
+	    if (cs->tags.follow != UNSPEC && cs->tags.follow != tags.follow)
+		printf("%sFOLLOW: ", cs->tags.follow ? "" : "NO");
 	    print_member(cs->cmnd);
 	    memcpy(&tags, &cs->tags, sizeof(tags));
 	}
--- a/toke.l
+++ b/toke.l
@@ -338,6 +338,16 @@ NOSETENV[[:blank:]]*:	{
 			    	return(NOSETENV);
 			}
 
+FOLLOW[[:blank:]]*:	{
+			    	LEXTRACE("FOLLOW ");
+			    	return(FOLLOW);
+			}
+
+NOFOLLOW[[:blank:]]*:	{
+			    	LEXTRACE("NOFOLLOW ");
+			    	return(NOFOLLOW);
+			}
+
 \+{WORD}		{
 			    /* netgroup */
 			    if (!fill(yytext, yyleng))
--- a/sudo_edit.c
+++ b/sudo_edit.c
@@ -58,6 +58,50 @@ static char *find_editor __P((int *argc_
 
 extern char **NewArgv; /* XXX */
 
+#ifdef O_NOFOLLOW
+static int
+sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+{
+    if (!ISSET(sflags, CD_SUDOEDIT_FOLLOW))
+	oflags |= O_NOFOLLOW;
+    return open(path, oflags, mode);
+}
+#else
+static int
+sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+{
+    struct stat sb1, sb2;
+    int fd;
+
+    fd = open(path, oflags, mode);
+    if (fd == -1 || ISSET(sflags, CD_SUDOEDIT_FOLLOW))
+	return fd;
+
+    /*
+     * Treat [fl]stat() failure like an open() failure.
+     */
+    if (fstat(fd, &sb1) == -1 || lstat(path, &sb2) == -1) {
+	const int serrno = errno;
+	close(fd);
+	errno = serrno;
+	return -1;
+    }
+
+    /*
+     * Make sure we did not open a link and that what we opened
+     * matches what is currently on the file system.
+     */
+    if (S_ISLNK(sb2.st_mode) ||
+	sb1.st_dev != sb2.st_dev || sb1.st_ino != sb2.st_ino) {
+	close(fd);
+	errno = ELOOP;
+	return -1;
+    }
+
+    return fd;
+}
+#endif /* O_NOFOLLOW */
+
 /*
  * Wrapper to allow users to edit privileged files with their own uid.
  */
@@ -82,6 +126,7 @@ sudo_edit(argc, argv, envp)
 	struct timeval omtim;
 	off_t osize;
     } *tf;
+    int sflags = def_sudoedit_follow ? CD_SUDOEDIT_FOLLOW : 0;
 
     /* Determine user's editor. */
     editor = find_editor(&editor_argc, &editor_argv);
@@ -114,7 +159,8 @@ sudo_edit(argc, argv, envp)
     for (i = 0, j = 0; i < nfiles; i++) {
 	rc = -1;
 	set_perms(PERM_RUNAS);
-	if ((ofd = open(files[i], O_RDONLY, 0644)) != -1 || errno == ENOENT) {
+	ofd = sudo_edit_open(files[i], O_RDONLY, 0644, sflags);
+	if (ofd != -1 || errno == ENOENT) {
 	    if (ofd == -1) {
 		zero_bytes(&sb, sizeof(sb));		/* new file */
 		rc = 0;
@@ -127,11 +173,17 @@ sudo_edit(argc, argv, envp)
 	    }
 	}
 	set_perms(PERM_ROOT);
-	if (rc || (ofd != -1 && !S_ISREG(sb.st_mode))) {
-	    if (rc)
-		warning("%s", files[i]);
+	if (ofd != -1 && !S_ISREG(sb.st_mode)) {
+	    warningx("%s: not a regular file", files[i]);
+	    close(ofd);
+	    continue;
+	}
+	if (rc == -1) {
+	    /* open() or fstat() error. */
+	    if (ofd == -1 && errno == ELOOP)
+		warningx("%s: is a symbolic link", files[i]);
 	    else
-		warningx("%s: not a regular file", files[i]);
+		warning("%s", files[i]);
 	    if (ofd != -1)
 		close(ofd);
 	    continue;
@@ -216,13 +268,9 @@ sudo_edit(argc, argv, envp)
     for (i = 0; i < nfiles; i++) {
 	rc = -1;
 	set_perms(PERM_USER);
-	if ((tfd = open(tf[i].tfile, O_RDONLY, 0644)) != -1) {
-#ifdef HAVE_FSTAT
+	tfd = sudo_edit_open(tf[i].tfile, O_RDONLY, 0644, 0);
+	if (tfd != -1)
 	    rc = fstat(tfd, &sb);
-#else
-	    rc = stat(tf[i].tfile, &sb);
-#endif
-	}
 	set_perms(PERM_ROOT);
 	if (rc || !S_ISREG(sb.st_mode)) {
 	    if (rc)
@@ -249,7 +297,8 @@ sudo_edit(argc, argv, envp)
 	    }
 	}
 	set_perms(PERM_RUNAS);
-	ofd = open(tf[i].ofile, O_WRONLY|O_TRUNC|O_CREAT, 0644);
+	ofd = sudo_edit_open(tf[i].ofile, O_WRONLY|O_TRUNC|O_CREAT, 0644,
+			     sflags);
 	set_perms(PERM_ROOT);
 	if (ofd == -1) {
 	    warning("unable to write to %s", tf[i].ofile);
--- a/sudo.h
+++ b/sudo.h
@@ -207,6 +207,8 @@ struct command_status {
 #define TGP_STDIN	0x02		/* read from stdin, not /dev/tty */
 #define TGP_ASKPASS	0x04		/* read from askpass helper program */
 
+#define CD_SUDOEDIT_FOLLOW	0x10000
+
 struct lbuf;
 struct passwd;
 struct stat;
