Description: CVE-2015-5602: Add directory writability checks for sudoedit.
Origin: https://www.sudo.ws/repos/sudo/rev/f5349d059a98
Bug: https://bugzilla.sudo.ws/show_bug.cgi?id=707
Bug-Debian: https://bugs.debian.org/804149
Author: Todd C. Miller <Todd.Miller@courtesan.com>
Author: Ben Hutchings <ben@decadent.org.uk>
Applied-Upstream: 1.8.15

--- a/configure.ac
+++ b/configure.ac
@@ -2311,7 +2311,7 @@ dnl Function checks
 dnl
 AC_FUNC_GETGROUPS
 AC_CHECK_FUNCS(glob nl_langinfo regcomp setenv strftime strrchr strtoll \
-	       sysconf tzset)
+	       sysconf tzset openat)
 AC_CHECK_FUNCS(getgrouplist, [], [
     case "$host_os" in
     aix*)
--- a/doc/sudoers.cat
+++ b/doc/sudoers.cat
@@ -1202,6 +1202,14 @@ SSUUDDOOEERRSS OOPPTTIIOONN
                        that support either the setreuid(2) or setresuid(2)
                        system call.  This flag is _o_f_f by default.
 
+     sudoedit_checkdir
+                       If set, ssuuddooeeddiitt will refuse to edit files located in a
+                       directory that is writable by the invoking user unless
+                       it is run by root.  On many systems, this option
+                       requires that the parent directory of the file to be
+                       edited be readable by the target user.  This flag is
+                       _o_f_f by default.
+
      sudoedit_follow   By default, ssuuddooeeddiitt will not follow symbolic links
                        when opening files.  The _s_u_d_o_e_d_i_t___f_o_l_l_o_w option can be
                        enabled to allow ssuuddooeeddiitt to open symbolic links.  It
--- a/doc/sudoers.man.in
+++ b/doc/sudoers.man.in
@@ -2546,6 +2546,18 @@ This flag is
 \fIoff\fR
 by default.
 .TP 18n
+sudoedit_checkdir
+.br
+If set,
+\fBsudoedit\fR
+will refuse to edit files located in a directory that is writable
+by the invoking user unless it is run by root.
+On many systems, this option requires that the parent directory
+of the file to be edited be readable by the target user.
+This flag is
+\fIoff\fR
+by default.
+.TP 18n
 sudoedit_follow
 By default,
 \fBsudoedit\fR
--- a/doc/sudoers.mdoc.in
+++ b/doc/sudoers.mdoc.in
@@ -2383,6 +2383,16 @@ system call.
 This flag is
 .Em off
 by default.
+.It sudoedit_checkdir
+If set,
+.Nm sudoedit
+will refuse to edit files located in a directory that is writable
+by the invoking user unless it is run by root.
+On many systems, this option requires that the parent directory
+of the file to be edited be readable by the target user.
+This flag is
+.Em off
+by default.
 .It sudoedit_follow
 By default,
 .Nm sudoedit
--- a/plugins/sudoers/def_data.in
+++ b/plugins/sudoers/def_data.in
@@ -283,6 +283,9 @@ maxseq
 use_netgroups
 	T_FLAG
 	"Enable sudoers netgroup support"
+sudoedit_checkdir
+	T_FLAG
+	"Check the parent directory for writability when editing files with sudoedit"
 sudoedit_follow
 	T_FLAG
 	"Follow symbolic links when editing files with sudoedit"
--- a/plugins/sudoers/policy.c
+++ b/plugins/sudoers/policy.c
@@ -397,6 +397,8 @@ sudoers_policy_exec_setup(char *argv[],
     }
     if (ISSET(sudo_mode, MODE_EDIT)) {
 	command_info[info_len++] = estrdup("sudoedit=true");
+	if (def_sudoedit_checkdir)
+	    command_info[info_len++] = estrdup("sudoedit_checkdir=true");
 	if (def_sudoedit_follow)
 	    command_info[info_len++] = estrdup("sudoedit_follow=true");
     }
--- a/src/sudo.c
+++ b/src/sudo.c
@@ -676,6 +676,11 @@ command_info_to_details(char * const inf
 			SET(details->flags, CD_SUDOEDIT);
 		    break;
 		}
+		if (strncmp("sudoedit_checkdir=", info[i], sizeof("sudoedit_checkdir=") - 1) == 0) {
+		    if (atobool(info[i] + sizeof("sudoedit_checkdir=") - 1) == true)
+			SET(details->flags, CD_SUDOEDIT_CHECKDIR);
+		    break;
+		}
 		if (strncmp("sudoedit_follow=", info[i], sizeof("sudoedit_follow=") - 1) == 0) {
 		    if (atobool(info[i] + sizeof("sudoedit_follow=") - 1) == true)
 			SET(details->flags, CD_SUDOEDIT_FOLLOW);
--- a/src/sudo.h
+++ b/src/sudo.h
@@ -123,6 +123,7 @@ struct user_details {
 #define CD_SET_UTMP		0x02000
 #define CD_EXEC_BG		0x04000
 #define CD_SUDOEDIT_FOLLOW	0x10000
+#define CD_SUDOEDIT_CHECKDIR	0x20000
 
 struct preserved_fd {
     TAILQ_ENTRY(preserved_fd) entries;
--- a/src/sudo_edit.c
+++ b/src/sudo_edit.c
@@ -40,6 +40,7 @@
 # include <unistd.h>
 #endif /* HAVE_UNISTD_H */
 #include <ctype.h>
+#include <errno.h>
 #include <grp.h>
 #include <pwd.h>
 #include <signal.h>
@@ -79,28 +80,180 @@ switch_user(uid_t euid, gid_t egid, int
     debug_return;
 }
 
+static bool
+group_matches(gid_t target, gid_t gid, int ngroups, GETGROUPS_T *groups)
+{
+    int i;
+    debug_decl(group_matches, SUDO_DEBUG_EDIT)
+
+    if (target == gid) {
+	sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,
+	    "user gid %u matches directory gid %u", (unsigned int)gid,
+	    (unsigned int)target);
+	debug_return_bool(true);
+    }
+    for (i = 0; i < ngroups; i++) {
+	if (target == groups[i]) {
+	    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,
+		"user gid %u matches directory gid %u", (unsigned int)gid,
+		(unsigned int)target);
+	    debug_return_bool(true);
+	}
+    }
+    debug_return_bool(false);
+}
+
+#ifndef HAVE_OPENAT
+/* This does not support AT_FDCWD... */
+static int
+sudo_openat(int dfd, const char *path, int flags, mode_t mode)
+{
+    int fd, odfd;
+    debug_decl(sudo_openat, SUDO_DEBUG_EDIT)
+
+    /* Save cwd */
+    if ((odfd = open(".", O_RDONLY)) == -1)
+	debug_return_int(-1);
+
+    if (fchdir(dfd) == -1) {
+	close(odfd);
+	debug_return_int(-1);
+    }
+
+    fd = open(path, flags, mode);
+
+    /* Restore cwd */
+    if (fchdir(odfd) == -1)
+	fatal(_("unable to restore current working directory"));
+    close(odfd);
+
+    debug_return_int(fd);
+}
+#define openat sudo_openat
+#endif /* HAVE_OPENAT */
+
+/*
+ * Returns true if the directory described by sb is writable
+ * by the user.  We treat directories with the sticky bit as
+ * unwritable unless they are owned by the user.
+ */
+static bool
+dir_is_writable(struct stat *sb, uid_t uid, gid_t gid, int ngroups,
+    GETGROUPS_T *groups)
+{
+    debug_decl(dir_is_writable, SUDO_DEBUG_EDIT)
+
+    /* If the user owns the dir we always consider it writable. */
+    if (sb->st_uid == uid) {
+	sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,
+	    "user uid %u matches directory uid %u", (unsigned int)uid,
+	    (unsigned int)sb->st_uid);
+	debug_return_bool(true);
+    }
+
+    /* Other writable? */
+    if (ISSET(sb->st_mode, S_IWOTH)) {
+	sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,
+	    "directory is writable by other");
+	debug_return_bool(true);
+    }
+
+    /* Group writable? */
+    if (ISSET(sb->st_mode, S_IWGRP)) {
+	if (group_matches(sb->st_gid, gid, ngroups, groups)) {
+	    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,
+		"directory is writable by one of the user's groups");
+	    debug_return_bool(true);
+	}
+    }
+
+    debug_return_bool(false);
+}
+
+static int
+sudo_edit_open_nonwritable(char *path, int oflags, mode_t mode)
+{
+    char *base, *dir;
+    struct stat sb;
+    int dfd, fd;
+    debug_decl(sudo_edit_open_nonwritable, SUDO_DEBUG_EDIT)
+
+    base = strrchr(path, '/');
+    if (base != NULL) {
+	*base++ = '\0';
+	dir = path;
+    } else {
+	base = path;
+	dir = ".";
+    }
+#ifdef O_PATH
+    if ((dfd = open(dir, O_PATH)) != -1) {
+	/* Linux kernels < 3.6 can't do fstat on O_PATH fds. */
+	if (fstat(dfd, &sb) == -1) {
+	    close(dfd);
+	    dfd = open(dir, O_RDONLY);
+	    if (fstat(dfd, &sb) == -1) {
+		close(dfd);
+		dfd = -1;
+	    }
+	}
+    }
+#else
+    if ((dfd = open(dir, O_RDONLY)) != -1) {
+	if (fstat(dfd, &sb) == -1) {
+	    close(dfd);
+	    dfd = -1;
+	}
+    }
+#endif
+    if (base != path)
+	base[-1] = '/';			/* restore path */
+    if (dfd == -1)
+	debug_return_int(-1);
+
+    if (dir_is_writable(&sb, user_details.uid, user_details.gid,
+	user_details.ngroups, user_details.groups)) {
+	close(dfd);
+	errno = ENOTDIR;
+	debug_return_int(-1);
+    }
+
+    fd = openat(dfd, path, oflags, mode);
+    close(dfd);
+    debug_return_int(fd);
+}
+
 #ifdef O_NOFOLLOW
 static int
-sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+sudo_edit_open(char *path, int oflags, mode_t mode, int sflags)
 {
     int fd;
+    debug_decl(sudo_edit_open, SUDO_DEBUG_EDIT)
 
     if (!ISSET(sflags, CD_SUDOEDIT_FOLLOW))
 	oflags |= O_NOFOLLOW;
-    fd = open(path, oflags|O_NONBLOCK, mode);
+    if (ISSET(sflags, CD_SUDOEDIT_CHECKDIR) && user_details.uid != 0)
+	fd = sudo_edit_open_nonwritable(path, oflags|O_NONBLOCK, mode);
+    else
+	fd = open(path, oflags|O_NONBLOCK, mode);
     if (fd != -1 && !ISSET(oflags, O_NONBLOCK))
 	(void) fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
-    return fd;
+    debug_return_int(fd);
 }
 #else
 static int
-sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+sudo_edit_open(char *path, int oflags, mode_t mode, int sflags)
 {
     struct stat sb1, sb2;
     int fd;
+    debug_decl(sudo_edit_open, SUDO_DEBUG_EDIT)
 
-    if ((fd = open(path, oflags|O_NONBLOCK, mode)) == -1)
-	return -1;
+    if (ISSET(sflags, CD_SUDOEDIT_CHECKDIR) && user_details.uid != 0)
+	fd = sudo_edit_open_nonwritable(path, oflags|O_NONBLOCK, mode);
+    else
+	fd = open(path, oflags|O_NONBLOCK, mode);
+    if (fd == -1)
+	debug_return_int(-1);
     if (!ISSET(oflags, O_NONBLOCK))
 	(void) fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
 
@@ -111,7 +264,7 @@ sudo_edit_open(const char *path, int ofl
 	const int serrno = errno;
 	close(fd);
 	errno = serrno;
-	return -1;
+	debug_return_int(-1);
     }
 
     /*
@@ -123,11 +276,11 @@ sudo_edit_open(const char *path, int ofl
 	    sb1.st_dev != sb2.st_dev || sb1.st_ino != sb2.st_ino) {
 	    close(fd);
 	    errno = ELOOP;
-	    return -1;
+	    debug_return_int(-1);
 	}
     }
 
-    return fd;
+    debug_return_int(fd);
 }
 #endif /* O_NOFOLLOW */
 
@@ -226,6 +379,9 @@ sudo_edit(struct command_details *comman
 	    if (ofd == -1 && errno == ELOOP) {
 		warningx(U_("%s: editing symbolic links is not permitted"),
 		    files[i]);
+	    } else if (ofd == -1 && errno == ENOTDIR) {
+		warningx(U_("%s: editing files in a writable directory is not permitted"),
+		    files[i]);
 	    } else {
 		warning("%s", files[i]);
 	    }
