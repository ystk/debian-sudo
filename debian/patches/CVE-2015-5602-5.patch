Description: CVE-2015-5602: Add directory writability checks for sudoedit.
Origin: https://www.sudo.ws/repos/sudo/rev/f5349d059a98
Bug: https://bugzilla.sudo.ws/show_bug.cgi?id=707
Bug-Debian: https://bugs.debian.org/804149
Author: Todd C. Miller <Todd.Miller@courtesan.com>
Author: Ben Hutchings <ben@decadent.org.uk>
Applied-Upstream: 1.8.15

--- a/configure.in
+++ b/configure.in
@@ -1919,7 +1919,7 @@ AC_FUNC_GETGROUPS
 AC_CHECK_FUNCS(strchr strrchr memchr memcpy memset sysconf tzset \
 	       strftime setrlimit initgroups getgroups fstat gettimeofday \
 	       regcomp setlocale getaddrinfo getsid setenv vhangup \
-	       mbr_check_membership setrlimit64)
+	       mbr_check_membership setrlimit64 openat)
 AC_CHECK_FUNCS(getline, [], [
     AC_LIBOBJ(getline)
     AC_CHECK_FUNCS(fgetln)
--- a/sudoers.pod
+++ b/sudoers.pod
@@ -875,6 +875,14 @@ dangerous functionality when a program i
 is only effective on systems with either the setreuid() or setresuid()
 function.  This flag is I<off> by default.
 
+=item sudoedit_checkdir
+
+If set, B<sudoedit> will refuse to edit files located in a directory
+that is writable by the invoking user unless it is run by root.
+On many systems, this option requires that the parent directory of
+the file to be edited be readable by the target user.  This flag is
+I<off> by default.
+
 =item sudoedit_follow
 
 By default, B<sudoedit> will not follow symbolic links when opening
--- a/def_data.in
+++ b/def_data.in
@@ -244,6 +244,9 @@ compress_io
 use_pty
 	T_FLAG
 	"Always run commands in a pseudo-tty"
+sudoedit_checkdir
+	T_FLAG
+	"Check the parent directory for writability when editing files with sudoedit"
 sudoedit_follow
 	T_FLAG
 	"Follow symbolic links when editing files with sudoedit"
--- a/sudo_edit.c
+++ b/sudo_edit.c
@@ -43,6 +43,7 @@
 # include <unistd.h>
 #endif /* HAVE_UNISTD_H */
 #include <ctype.h>
+#include <errno.h>
 #include <grp.h>
 #include <pwd.h>
 #include <signal.h>
@@ -58,27 +59,158 @@ static char *find_editor __P((int *argc_
 
 extern char **NewArgv; /* XXX */
 
+static int
+group_matches(gid_t target, gid_t gid, int ngroups, GETGROUPS_T *groups)
+{
+    int i;
+
+    if (target == gid) {
+	return TRUE;
+    }
+    for (i = 0; i < ngroups; i++) {
+	if (target == groups[i]) {
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+#ifndef HAVE_OPENAT
+/* This does not support AT_FDCWD... */
+static int
+sudo_openat(int dfd, const char *path, int flags, mode_t mode)
+{
+    int fd, odfd;
+
+    /* Save cwd */
+    if ((odfd = open(".", O_RDONLY)) == -1)
+	return -1;
+
+    if (fchdir(dfd) == -1) {
+	close(odfd);
+	return -1;
+    }
+
+    fd = open(path, flags, mode);
+
+    /* Restore cwd */
+    if (fchdir(odfd) == -1)
+	error(1, "unable to restore current working directory");
+    close(odfd);
+
+    return fd;
+}
+#define openat sudo_openat
+#endif /* HAVE_OPENAT */
+
+/*
+ * Returns true if the directory described by sb is writable
+ * by the user.  We treat directories with the sticky bit as
+ * unwritable unless they are owned by the user.
+ */
+static int
+dir_is_writable(struct stat *sb, uid_t uid, gid_t gid, int ngroups,
+    GETGROUPS_T *groups)
+{
+    /* If the user owns the dir we always consider it writable. */
+    if (sb->st_uid == uid) {
+	return TRUE;
+    }
+
+    /* Other writable? */
+    if (ISSET(sb->st_mode, S_IWOTH)) {
+	return TRUE;
+    }
+
+    /* Group writable? */
+    if (ISSET(sb->st_mode, S_IWGRP)) {
+	if (group_matches(sb->st_gid, gid, ngroups, groups)) {
+	    return TRUE;
+	}
+    }
+
+    return FALSE;
+}
+
+static int
+sudo_edit_open_nonwritable(char *path, int oflags, mode_t mode)
+{
+    char *base, *dir;
+    struct stat sb;
+    int dfd, fd;
+
+    base = strrchr(path, '/');
+    if (base != NULL) {
+	*base++ = '\0';
+	dir = path;
+    } else {
+	base = path;
+	dir = ".";
+    }
+#ifdef O_PATH
+    if ((dfd = open(dir, O_PATH)) != -1) {
+	/* Linux kernels < 3.6 can't do fstat on O_PATH fds. */
+	if (fstat(dfd, &sb) == -1) {
+	    close(dfd);
+	    dfd = open(dir, O_RDONLY);
+	    if (fstat(dfd, &sb) == -1) {
+		close(dfd);
+		dfd = -1;
+	    }
+	}
+    }
+#else
+    if ((dfd = open(dir, O_RDONLY)) != -1) {
+	if (fstat(dfd, &sb) == -1) {
+	    close(dfd);
+	    dfd = -1;
+	}
+    }
+#endif
+    if (base != path)
+	base[-1] = '/';			/* restore path */
+    if (dfd == -1)
+	return -1;
+
+    if (dir_is_writable(&sb, user_uid, user_gid, user_ngroups, user_groups)) {
+	close(dfd);
+	errno = ENOTDIR;
+	return -1;
+    }
+
+    fd = openat(dfd, path, oflags, mode);
+    close(dfd);
+    return fd;
+}
+
 #ifdef O_NOFOLLOW
 static int
-sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+sudo_edit_open(char *path, int oflags, mode_t mode, int sflags)
 {
     int fd;
 
     if (!ISSET(sflags, CD_SUDOEDIT_FOLLOW))
 	oflags |= O_NOFOLLOW;
-    fd = open(path, oflags|O_NONBLOCK, mode);
+    if (ISSET(sflags, CD_SUDOEDIT_CHECKDIR) && user_uid != 0)
+	fd = sudo_edit_open_nonwritable(path, oflags|O_NONBLOCK, mode);
+    else
+	fd = open(path, oflags|O_NONBLOCK, mode);
     if (fd != -1 && !ISSET(oflags, O_NONBLOCK))
 	(void) fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
     return fd;
 }
 #else
 static int
-sudo_edit_open(const char *path, int oflags, mode_t mode, int sflags)
+sudo_edit_open(char *path, int oflags, mode_t mode, int sflags)
 {
     struct stat sb1, sb2;
     int fd;
 
-    if ((fd = open(path, oflags|O_NONBLOCK, mode)) == -1)
+    if (ISSET(sflags, CD_SUDOEDIT_CHECKDIR) && user_uid != 0)
+	fd = sudo_edit_open_nonwritable(path, oflags|O_NONBLOCK, mode);
+    else
+	fd = open(path, oflags|O_NONBLOCK, mode);
+    if (fd == -1)
 	return -1;
     if (!ISSET(oflags, O_NONBLOCK))
 	(void) fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK);
@@ -134,7 +266,8 @@ sudo_edit(argc, argv, envp)
 	struct timeval omtim;
 	off_t osize;
     } *tf;
-    int sflags = def_sudoedit_follow ? CD_SUDOEDIT_FOLLOW : 0;
+    int sflags = ((def_sudoedit_checkdir ? CD_SUDOEDIT_CHECKDIR : 0) |
+		  (def_sudoedit_follow ? CD_SUDOEDIT_FOLLOW : 0));
 
     /* Determine user's editor. */
     editor = find_editor(&editor_argc, &editor_argv);
@@ -191,6 +324,9 @@ sudo_edit(argc, argv, envp)
 	    if (ofd == -1 && errno == ELOOP) {
 		warningx("%s: editing symbolic links is not permitted",
 		    files[i]);
+	    } else if (ofd == -1 && errno == ENOTDIR) {
+		warningx("%s: editing files in a writable directory is not permitted",
+		    files[i]);
 	    } else {
 		warning("%s", files[i]);
 	    }
--- a/sudo.h
+++ b/sudo.h
@@ -208,6 +208,7 @@ struct command_status {
 #define TGP_ASKPASS	0x04		/* read from askpass helper program */
 
 #define CD_SUDOEDIT_FOLLOW	0x10000
+#define CD_SUDOEDIT_CHECKDIR	0x20000
 
 struct lbuf;
 struct passwd;
